<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>advent of code 2020: lazy tobogganing - Norman Liu's blog</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;500&family=Space+Mono&display=swap" rel="stylesheet">

        
          <meta name="author" content="Norman Liu">
        
        
          <meta name="keywords" content="advent, haskell, programming">
        


    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">normative statements</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <span class="delim">
                    >>
                </span>
                <a href="../about.html">About</a>
                <span class="delim">
                    >>
                </span>
                <a href="../contact.html">Contact</a>
                <span class="delim">
                    >>
                </span>
                <a href="../archive.html">Archive</a>
            </nav>
            <hr class="head_delim">
        </header>

        <div id="page-container">
          <div id="content">
        <main role="main">
                        <article>
    <section class="header">
      <h1>advent of code 2020: lazy tobogganing</h1>
      Written: <span class="date">2020-12-02</span> 
      
      to <span class="date">2020-12-02</span>
      
        
        <br>
        by <a href="../about.html"><span class="name">Norman Liu</span></a>
        <br>
        
    </section>
    <section>
        <p>It’s December, so you know what that means.</p>
<p>Debt? Maybe. Alcoholism? No time. Time to save Santa again? Yep.</p>
<p><a href="https://adventofcode.com">Advent of Code</a> is finally back, and so everybody’s in full motion trying to contort their favourite languages into workable problem-solving tools, me included. I’ve been a huge fan of Advent of Code ever since I started programming, and I love going back and working on old problems when Leetcode and Codewars get boring. I’m hoping for some problems spread out over several days that involve incremental and visible progress, like last year’s <a href="https://adventofcode.com/2019/day/2">Intcode computer</a>.</p>
<p>Today’s problem is relatively simple - even though you’ve travelled through <a href="https://adventofcode.com/2019/day/1">space</a>, <a href="https://adventofcode.com/2018/day/1">time</a>, and into <a href="https://adventofcode.com/2017/day/1">Santa’s computer</a>, you still rely on sled-based transportation to get to the airport. This is a task fraught with danger, because trees litter the landscape more than potholes mark the 401. Given a map of the area and two integers denoting rise and run, your task is to figure out how many trees you’ll collide with on your path.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">example ::</span> [<span class="dt">Char</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>example <span class="ot">=</span> <span class="st">&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="st">  ..##.......</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="st">  #...#...#..</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="st">  .#....#..#.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="st">  ..#.#...#.#</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="st">  .#...##..#.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="st">  ..#.##.....</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="st">  .#.#.#....#</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="st">  .#........#</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="st">  #.##...#...</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="st">  #...##....#</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="st">  .#..#...#.#</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="st">  &quot;</span></span></code></pre></div>
<p><code>#</code>’s represent trees and <code>.</code>’s are empty land. Mercifully, we won’t need to deal with floating-point calculations for this problem.</p>
<p>The landscape repeats itself horizontally, so running off the right side of the map will just put you back where you started. Starting from the top left of the map and a rise and run of <code>(3, 1)</code>, how many trees will we collide with?</p>
<p>Let’s start off by making our problem a little easier. We can’t directly add booleans in Haskell, and binary looks way cleaner anyways. <code>cycle</code> takes a list and loops it in itself, creating an infinite generator.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Function</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ot">inp2Int ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>inp2Int <span class="ot">=</span> <span class="fu">lines</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> (<span class="fu">cycle</span> <span class="op">.</span> <span class="fu">fmap</span> (\c <span class="ot">-&gt;</span> ((c <span class="op">==</span> <span class="ch">'.'</span>) <span class="op">?</span> <span class="dv">0</span> <span class="op">$</span> <span class="dv">1</span>)))</span></code></pre></div>
<p>“Wait, Haskell doesn’t have ternary operators?” you say, bound to the shackles of built-in syntax.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">(?) ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>(<span class="op">?</span>) <span class="dt">True</span> <span class="ot">=</span> <span class="fu">const</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>(<span class="op">?</span>) _ <span class="ot">=</span> <span class="fu">const</span> <span class="fu">id</span></span></code></pre></div>
<p>If you were writing this in a language where space matters, you might implement the rollover function using bit rotation. Lazy lists are more fun.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">slide ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>slide run <span class="ot">=</span> (<span class="fu">iterate</span> (<span class="fu">fmap</span> (<span class="fu">drop</span> run) <span class="op">&gt;&gt;&gt;</span> <span class="fu">tail</span>) <span class="op">&gt;&gt;=</span> <span class="fu">zipWith</span> <span class="fu">const</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">fmap</span> <span class="fu">head</span></span></code></pre></div>
<p>We can just walk down our list of infinite rows, dropping the first <code>run</code> elements of each stream at every turn. It’s not <em>too</em> efficient for gigantic inputs, but it’s elegant. We take a list, repeatedly mapping <code>drop run</code> over it, and stepping down to the next stream. Using the <code>Monad</code> instance for functions (aka the <code>Reader</code> monad), we can take advantage of the fact that <code>iterate (fmap (drop run) &gt;&gt;&gt; tail)</code> is a single-argument function, and <code>zipWith const</code> takes two arguments. This fulfills the <code>m a -&gt; (a -&gt; m b) -&gt; m b</code> requirement for monadic binding, and so we can apply them to the same input without having to pollute our code with cruft. Can you imagine <strong>actually</strong> naming arguments?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="fu">return</span> <span class="ot">=</span> <span class="fu">const</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> \r <span class="ot">-&gt;</span> f (x r) r</span></code></pre></div>
<p>You can do the same thing with <code>liftA2 f x id</code>, but that’s less concise and you can’t show off your monad wizardry. This might seem like dangerous code, as <code>iterate</code> doesn’t stop applying its given transformation, and <code>tail</code> is a partial function. Usually, you would incur a runtime error from taking the tail of an empty list, but that’s fine. <code>zipWith</code> is bounded to the length of the shorter input list, and so we consume exactly as many inputs from <code>iterate</code> as there are in the original list. Any more, and Haskell would crash on us. It’s still arguably less dangerous than crashing into trees.</p>
<p>A more intuitive version of <code>slide</code> might look like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">meander ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>meander _ [] <span class="ot">=</span> []</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>meander run (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> meander run (<span class="fu">drop</span> run <span class="op">&lt;$&gt;</span> xs)</span></code></pre></div>
<p>Let’s try it out.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="op">&gt;</span> slide <span class="dv">1</span> [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>],[<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>]]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">5</span>,<span class="dv">6</span>],[<span class="dv">9</span>]]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="op">&gt;</span> <span class="fu">map</span> (<span class="fu">take</span> <span class="dv">8</span>) <span class="op">$</span> slide <span class="dv">1</span> (<span class="fu">map</span> <span class="fu">cycle</span> [[<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>], [<span class="dv">11</span><span class="op">..</span><span class="dv">15</span>], [<span class="dv">21</span><span class="op">..</span><span class="dv">25</span>]])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>[</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>  [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  [<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>],</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>  [<span class="dv">23</span>,<span class="dv">24</span>,<span class="dv">25</span>,<span class="dv">21</span>,<span class="dv">22</span>,<span class="dv">23</span>,<span class="dv">24</span>,<span class="dv">25</span>]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>]</span></code></pre></div>
<p>We’ve basically solved the problem at this point. We’ve figured out how to model stepping forward, and all that remains is to chain these functions together. Recall that the prompt is asking us to output the amount of trees that we have the misfortune of encountering on our journey, and so:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">toboggan ::</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>   </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>toboggan xs run rise <span class="ot">=</span> xs <span class="op">&amp;</span> (chunksOf rise <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> <span class="fu">head</span> <span class="op">&gt;&gt;&gt;</span> slide run <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> <span class="fu">head</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span>)</span></code></pre></div>
<p>I’ve recently started using arrows to compose functions from left-to-right, and I’m loving the readability of my code now. The reason why our arguments are backwards will become apparent in the second part of the problem. In the meantime though, we’ve done it!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">day3Pt1 ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>day3Pt1 <span class="ot">=</span> inp2Int <span class="op">&gt;&gt;&gt;</span> <span class="fu">flip</span> (<span class="fu">flip</span> toboggan <span class="dv">3</span>) <span class="dv">1</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="op">&gt;</span> day3Pt1 example</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="dv">176</span></span></code></pre></div>
<p>Infinite lists are magical when you don’t have to consume them in their entirety.</p>
<p>[Part 2 writeup to come soon!]</p>
    </section>
</article>

        </main>

          </div>
        <footer>
            <hr>
            <span style="color:yellow">λ</span> Copyright 2020 - Norman Liu.  Site powered by 
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
        </footer>
        </div>
    </body>
</html>
